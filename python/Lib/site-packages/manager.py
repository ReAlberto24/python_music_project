from multiprocessing import Process, Manager
from threading import Thread
from subprocess import Popen, PIPE, run
from typing import Any
import traceback

class ProcessException(Exception):
    '''Called when a Exception is raised inside a Process'''
    pass

class ThreadException(Exception):
    '''Called when a Exception is raised inside a Thread'''
    pass

class SubprocessException(Exception):
    '''Called when a Exception is raised inside a SubProcess'''
    pass

version = '2.0'
processes = []
killable_threads = []
threads = []

def close_all_processes() -> None:
    for i in processes:
        i.terminate()

def close_all_threads() -> None:
    for i in killable_threads:
        i.terminate()

def worker(namespace, arguments:list) -> None:
    try:
        namespace.rtrn = arguments[0](
                *arguments[1],
                **arguments[2]
            )
    except Exception as expt:
        namespace.expt = expt
        namespace.tracebk = traceback.format_exc()
    return None

class process:
    '''
    Create a new process.
    '''
    def __init__(self, func:Any, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.manager = Manager()
        self.namespace = self.manager.Namespace()

        self.namespace.expt = None
        self.namespace.rtrn = None
        self.namespace.tracebk = None

        self.process = Process(target=worker, args=(self.namespace, [func, args, kwargs]), daemon=True)
        #co.processes.append([func.__name__, self.process])
        processes.append(self)

        return None

    def run(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.process.run()
        return None

    def join(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.process.join()
        return None

    def start(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.process.start()
        return None

    def terminate(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.process.terminate()
        return None

    def kill(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.process.kill()
        return None

    def get_return(self, *args:list[Any], **kwargs:dict[Any, Any]) -> Any:
        self.process.join()
        if self.namespace.expt != None:    
            #raise ProcessException(self.namespace.expt)
            raise ProcessException('A Exception was raised inside a Process\n\n'+self.namespace.tracebk)
        else:
            return self.namespace.rtrn

class thread:
    '''
    Create a new thread, that can't be killed.
    '''
    def __init__(self, func:Any, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.manager = Manager()
        self.namespace = self.manager.Namespace()

        self.namespace.expt = None
        self.namespace.rtrn = None
        self.namespace.tracebk = None

        self.thread = Thread(target=worker, args=(self.namespace, [func, args, kwargs]), daemon=True)
        #co.threads.append([func.__name__, self.thread])
        threads.append(self)

        return None

    def run(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.thread.run()
        return None

    def join(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.thread.join()
        return None

    def start(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.thread.start()
        return None

    def get_return(self, *args:list[Any], **kwargs:dict[Any, Any]) -> Any:
        self.thread.join()
        if self.namespace.expt != None:
            # raise ThreadException(self.namespace.expt)
            raise ThreadException('A Exception was raised inside a Thread\n\n'+self.namespace.tracebk)
        else:
            return self.namespace.rtrn

def killable_worker(namespace, runable_namespace, arguments:list) -> None:
    try:
        namespace.rtrn = arguments[0](
                runable_namespace,
                *arguments[1],
                **arguments[2]
            )
    except Exception as expt:
        namespace.expt = expt
        namespace.tracebk = traceback.format_exc()
    return None

class killable_thread:
    '''
    Create a new thread, that can be killed.

    To make it killable add runable as a argument of the function, 
    then in a while loop use runable.run instead of True

    Example
    ```python
    def foo(runable, *args):
        while runable.run:
            print('Hello World!')
    ```
    '''
    def __init__(self, func:Any, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.manager = Manager()
        self.namespace = self.manager.Namespace()

        self.namespace.expt = None
        self.namespace.rtrn = None
        self.namespace.tracebk = None

        self.runable_namespace = Manager().Namespace()
        self.runable_namespace.run = True

        self.thread = Thread(target=killable_worker, args=(self.namespace, self.runable_namespace, [func, args, kwargs]), daemon=True)
        #co.threads.append([func.__name__, self.thread])
        killable_threads.append(self)

        return None

    def run(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.thread.run()
        return None

    def join(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.thread.join()
        return None

    def start(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.thread.start()
        return None

    def terminate(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.runable_namespace.run = False
        return None

    def kill(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.terminate()
        return None

    def get_return(self, *args:list[Any], **kwargs:dict[Any, Any]) -> Any:
        self.thread.join()
        if self.namespace.expt != None:
            # raise ThreadException(self.namespace.expt)
            raise ThreadException('A Exception was raised inside a Thread\n\n'+self.namespace.tracebk)
        else:
            return self.namespace.rtrn

class subprocess:
    '''
    Call a new process using the command line.
    '''
    def __init__(self, executable:str, exec_args:list[str], shell:bool = False, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        # capture_output:bool = False
        # self.subprocess = Popen(
        #     exec_args,
        #     executable=executable, 
        #     shell=shell, 
        #     # capture_output=capture_output,
        #     stdout=PIPE, 
        #     stderr=PIPE,
        #     text=True
        #     ) # type: ignore
        
        self.subprocess = Popen(
            exec_args,
            2048,
            executable,
            PIPE,
            PIPE,
            PIPE,
            shell=shell
        )

    def get_return(self, *args:list[Any], **kwargs:dict[Any, Any]) -> Any:
        return self.subprocess.communicate()
    
    def poll(self, *args:list[Any], **kwargs:dict[Any, Any]) -> int|None:
        return self.subprocess.poll()

    def wait(self, time:float = 0.0, *args:list[Any], **kwargs:dict[Any, Any]) -> Any:
        return self.subprocess.wait(time)

    def terminate(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.subprocess.terminate()
        return None

    def kill(self, *args:list[Any], **kwargs:dict[Any, Any]) -> None:
        self.subprocess.kill()
        return None

    def args(self, *args:list[Any], **kwargs:dict[Any, Any]) -> Any:
        return self.subprocess.args

def pool_worker(namespace, pool_currect_func, arguments:list) -> None:
    while namespace.worker_run[pool_currect_func]:
        if not namespace.worker_set[pool_currect_func]:
            continue

        try:
            namespace.pool_rtrn[pool_currect_func] = namespace.current_func(
                    *arguments[0],
                    **arguments[1]
                )
        except Exception as expt:
            namespace.pool_expt[pool_currect_func] = expt
            namespace.pool_tracebk[pool_currect_func] = traceback.format_exc()
    return None

def killable_pool_worker(namespace, pool_currect_func, arguments:list) -> None:
    while namespace.worker_run[pool_currect_func]:
        if not namespace.worker_set[pool_currect_func]:
            continue

        try:
            namespace.pool_rtrn[pool_currect_func] = namespace.current_func(
                    namespace.worker_run,
                    pool_currect_func,
                    *arguments[0],
                    **arguments[1]
                )
        except Exception as expt:
            namespace.pool_expt[pool_currect_func] = expt
            namespace.pool_tracebk[pool_currect_func] = traceback.format_exc()
    return None

def worker_manager(namespace, arguments:list):
    while namespace.manager_worker_run:
        pass


# class create_pool:
#     def __init__(self, use_type:int = 0|1, number_of_n:int = 1) -> None:
#         self.manager = Manager()
#         self.namespace = self.manager.Namespace()
# 
#         self.namespace.expt = [None for i in range(number_of_n)]
#         self.namespace.tracebk = [None for i in range(number_of_n)]
#         self.namespace.rtrn = [None for i in range(number_of_n)]
#         self.namespace.worker_run = [True for i in range(number_of_n)]
#         self.namespace.worker_set = [False for i in range(number_of_n)]
#         self.namespace.worker_func_args = [[] for i in range(number_of_n)]
#         self.namespace.manager_worker_run = False
# 
#         self.type = use_type
#         self.count = number_of_n
#         self.n_type_list = []
#         self.namespace.function_pool = []
# 
#         if use_type == 0: # Processes
#             for n_to_create in range(number_of_n):
#                 c_process = process(pool_worker, self.namespace) # type: ignore
#                 c_process.run()
#                 self.n_type_list.append(c_process)
# 
#         elif use_type == 1: # Threads
#             for n_to_create in range(number_of_n):
#                 c_thread = killable_thread(killable_pool_worker, self.namespace) # type: ignore
#                 c_thread.start()
#                 self.n_type_list.append(c_thread)
# 
#         else:
#             raise Exception('Use a valid type')
#         
#         return None
#     
#     def pool_add(self, func:list[Any]|list[list[Any]], *args:list, **kwargs:dict) -> None:
#         type_name = type(func[0]).__name__
#         if type_name == 'list' or type_name == 'tuple':
#             for i in func:
#                 self.namespace.function_pool.append(i)
#         else:
#             self.namespace.function_pool.append(func)
#         
#         return None
# 
#     def run(self, *args:list, **kwargs:dict) -> None:
#         self.manager_thread = killable_thread()
# 
#     # TODO: For later 
#     # def close_all(self, *args:list, **kwargs:dict) -> None:
#     #     for n_list in self.n_type_list:
#     #         n_list.terminate()
#     #     return None
